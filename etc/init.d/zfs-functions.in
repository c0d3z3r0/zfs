# This is a script with common functions etc used by zfs-import, zfs-mount,
# zfs-share and zfs-zed.
#
# It is _NOT_ to be called independently
#
# Released under the 2-clause BSD license.
#
# The original script that acted as a template for this script came from
# the Debian GNU/Linux kFreeBSD ZFS packages (which did not include a
# licensing stansa) in the commit dated Mar 24, 2011:
#   https://github.com/zfsonlinux/pkg-zfs/commit/80a3ae582b59c0250d7912ba794dca9e669e605a

PATH=/sbin:/bin:/usr/bin:/usr/sbin

# Paths to what we need
ZFS="@sbindir@/zfs"
ZED="@sbindir@/zed"
ZPOOL="@sbindir@/zpool"
ZPOOL_CACHE="@sysconfdir@/zfs/zpool.cache"

# Sensible defaults
ZFS_MOUNT='yes'
ZFS_UNMOUNT='yes'

export ZFS ZED ZPOOL ZPOOL_CACHE ZFS_MOUNT ZFS_UNMOUNT

# Source zfs configuration, overriding the defaults
if [ -f @initconfdir@/zfs ]; then
	. @initconfdir@/zfs
fi

# ----------------------------------------------------

# Source function library
if [ -f /etc/rc.d/init.d/functions ]; then
	# RedHat and derivates
	. /etc/rc.d/init.d/functions
elif [ -f /etc/init.d/functions.sh ]; then
	# Gentoo
	. /etc/init.d/functions.sh
elif [ -f /lib/lsb/init-functions ]; then
	# LSB, Debian GNU/Linux and derivates
	. /lib/lsb/init-functions
fi

# helpers
do_noout() { "$@" >/dev/null; }
do_noerr() { "$@" 2>/dev/null; }
do_quiet() { "$@" >/dev/null 2>/dev/null; }

# Of course the functions we need are called differently
# on different distributions - it would be way too easy
# otherwise!!
if do_noout type log_failure_msg
then
	# LSB functions - fall through
	zfs_log_begin_msg() { log_begin_msg "${1}"; }
	zfs_log_end_msg() { log_end_msg "${1}"; }
	zfs_log_failure_msg() { log_failure_msg "${1}"; }
	zfs_log_progress_msg() { log_progress_msg "${1}"; }

elif do_noout type success
then
	# Fedora/RedHat functions
	zfs_set_ifs() {
		# For some reason, the init function library have a problem
		# with a changed IFS, so this function goes around that.
		local tIFS="${1}"

		if [ -n "${tIFS}" ]
		then
			TMP_IFS="${IFS}"
			IFS="${tIFS}"
		fi
	}

	zfs_log_begin_msg() { echo -n "${1} "; }
	zfs_log_end_msg() {
		zfs_set_ifs "${OLD_IFS}" # TODO: ?OLD_IFS???
		[ "${1}" -eq 0 ] && success || failure
		echo
		zfs_set_ifs "${TMP_IFS}"
	}
	zfs_log_failure_msg() {
		zfs_set_ifs "${OLD_IFS}"
		failure
		echo
		zfs_set_ifs "${TMP_IFS}"
	}
	zfs_log_progress_msg() { echo -n $"${1}"; }  # TODO: does not work!?

elif do_noout type einfo
then
	# Gentoo functions
	zfs_log_begin_msg() { ebegin "${1}"; }
	zfs_log_end_msg() { eend "${1}"; }
	zfs_log_failure_msg() { eend "${1}"; }
#	zfs_log_progress_msg() { echo -n "${1}"; }
	zfs_log_progress_msg() { echo -n; }

else
	# Unknown - simple substitues.
	zfs_log_begin_msg() { echo -n "${1}"; }
	zfs_log_end_msg() {
		local ret=${1}
		[ "${ret}" -ge 1 ] && echo " failed!" || echo " success"
		return "${ret}"
	}
	zfs_log_failure_msg() { echo "${1}"; }
	zfs_log_progress_msg() { echo -n "${1}"; }
fi

# Helper for converting (fixing...) some specialities of (m|fs)tab for
# regex matching.
#
# args:		-
# pipe:		(part of) regex
# output:	encoded regex
# returns:	-
#
convert_tabregex()
{
 # normalize any possible form of space or \040
 # normalize any possible form of \t or \011
 # then map . to [^ ], but keep \.* etc.
 sed -r 's/\0/\\0/g; s/ /\\\\\\040/g;
   s/\t/\\\\\\011/g;
   s/(^|[^\\])\./\1[^ ]/g'
}

# Simple argument parser
#
# args:		argument name (e.g. dev)
#		arguments (e.g. "${args}" or "$@")
# output:	argument value
# returns:	-
#
parsearg()
{
	local argname="${1}"

	while shift 2>/dev/null
	do
		[ "${1%%=*}" = "${argname}" ] && \
		    /bin/echo "${1##*=}" && \
		    break
	done
}

# ----------------------------------------------------

zfs_action()
{
	local msg="${1}";	shift
	local cmd="$*"
	local ret

	zfs_log_begin_msg "${msg} "
	${cmd}
	ret=$?

	[ "${ret}" -eq 0 ] && zfs_log_end_msg ${ret} || \
	    zfs_log_failure_msg ${ret}

	return ${ret}
}

# Returns
#   0 if daemon has been started
#   1 if daemon was already running
#   2 if daemon could not be started
#   3 if unsupported
#
zfs_daemon_start()
{
	local pidfile="${1}";		shift
	local daemon_bin="${1}";	shift
	local daemon_args="$*"

	if do_noout type start-stop-daemon
	then
		# LSB functions
		start-stop-daemon --quiet --start --test \
		    --pidfile "${pidfile}" --exec "${daemon_bin}" || \
		    return 1

		start-stop-daemon --quiet --start \
		    --exec "${daemon_bin}" -- "${daemon_args}" || \
		    return 2

		# On Debian GNU/Linux, there's a 'sendsigs' script that will
		# kill basically everything quite early and zed is stopped
		# much later than that. We don't want zed to be among them,
		# so add the zed pid to list of pids to ignore.
		[ -f "${pidfile}" -a -d /run/sendsigs.omit.d ] && \
		    ln -sf "${pidfile}" /run/sendsigs.omit.d/zed

	elif do_noout type daemon
	then
	        # Fedora/RedHat functions
		daemon --pidfile "${pidfile}" "${daemon_bin}" \
		    "${daemon_args}" || \
		    return 3

	else
		# Unsupported
		return 255
	fi

	return 0
}

# Returns
#   0 if daemon has been stopped
#   1 if daemon was already stopped
#   2 if daemon could not be stopped
#   3 if unsupported
#
zfs_daemon_stop()
{
	local pidfile="${1}";		shift
	local daemon_bin="${1}";	shift
	local daemon_name="${1}"

	if do_noout type start-stop-daemon; then
		# LSB functions
		start-stop-daemon --quiet --stop \
		    --pidfile "${pidfile}" --name "${daemon_name}" \
		    --retry=TERM/30/KILL/5

	elif do_noout type killproc; then
		# Fedora/RedHat functions
		killproc -p "${pidfile}" "${daemon_name}"

	else
		# Unsupported
		return 3
	fi

	return $?
}

# Returns status
zfs_daemon_status()
{
	local pidfile="${1}";		shift
	local daemon_bin="${1}";	shift
	local daemon_name="${1}"

	if do_noout type status_of_proc
	then
		# LSB functions
		status_of_proc "${daemon_name}" "${daemon_bin}"

	elif do_noout type status
	then
		# Fedora/RedHat functions
		status -p "${pidfile}" "${daemon_name}"

	else
		# Unsupported
		return 3
	fi

	return $?
}

zfs_daemon_reload()
{
	local pidfile="${1}";	shift
	local daemon_name="${1}"

	if do_noout type start-stop-daemon
	then
		# LSB functions
		start-stop-daemon --quiet --stop --signal 1 \
		    --pidfile "${pidfile}" --name "${daemon_name}"

	elif do_noout type killproc
	then
		# Fedora/RedHat functions
                killproc -p "${pidfile}" "${daemon_name}" -HUP

	else
		# Unsupported
		return 3
	fi

	return $?
}

# Test if a cmd is working
# args:		cmd
# output:	-
# returns:	cmd return code
test_zfs_cmd() {
	local cmd=${1}

	# Test if it works
	# (will catch missing binary and missing/broken libs etc)
	do_noout "${cmd}" -?

	return $?
}

# Check if zfs is installed and working
# args:		-
# output:	-
# returns:	0 or failed cmd number
zfs_installed()
{
	test_zfs_cmd "${ZPOOL}" || return 1
	test_zfs_cmd "${ZFS}" || return 2

	return 0
}

# Trigger udev and wait for it to settle.
#
# args:		-
# output:	-
# returns:	return code of settle command
#
udev_trigger()
{
	if [ -x /sbin/udevadm ]
	then
		/sbin/udevadm trigger --action=change --subsystem-match=block
		/sbin/udevadm settle

	elif [ -x /sbin/udevsettle ]
	then
		/sbin/udevtrigger
		/sbin/udevsettle
	fi

	return $?
}

# Do a lot of checks to make sure it's 'safe' to continue with the import.
#
# args:		-
# output:	-
# returns:	0 or error code, exits 3 if not called from init
#
checksystem()
{
	if grep -qEi '(^|[^\\](\\\\)* )zfs=(off|no|0)( |$)' /proc/cmdline;
	then
		# Called with zfs=(off|no|0) - bail because we don't
		# want anything import, mounted or shared.
		# HOWEVER, only do this if we're called at the boot up
		# (from init), not if we're running interactivly (as in
		# from the shell - we know what we're doing).
		[ -n "${init}" ] && exit 3
	fi

	# Check if ZFS is installed.
	zfs_installed || return 5

	# Just make sure that /dev/zfs is created.
	udev_trigger

	if [ "$(uname -m)" != "x86_64" ]; then
		echo "Warning: You're not running 64bit. Currently native zfs in" >&2
		echo "         Linux is only supported and tested on 64bit."  >&2
		# should we break here? People doing this should know what they
		# do, thus i'm not breaking here.
	fi

	return 0
}

# Get the root pool from current mounts
#
# args:		-
# output:	root pool name
# returns:	-
#
get_root_pool()
{
	get_mtab_entry mntpt="/" type="zfs" | (
	    IFS="\0" read -r dev _;
	    echo "${dev%%/*}";
	)
}

# Convert text variable to boolean
#
# args:		variable
# output:	-
# returns:	boolean
#
check_boolean()
{
	local var="${1}"

	echo "${var}" | grep -qEi '^(yes|on|true|1)$'

	return $?
}

# Check if a module is currently loaded (or built-in)
#
# args:		module name
# output:	-
# returns:	boolean
#
check_module_loaded()
{
	local module="${1}"

	[ -r "/sys/module/${module}/version" ]

	return $?
}

# Load a module
#
# args:	module name
# output:	-
# returns:	0 or error code
#
load_module()
{
	local module="${1}"

	# Load the zfs module stack
	check_module_loaded "${module}" || \
	    /sbin/modprobe "${module}" || \
	    return 5

    	return 0
}

# Filter tabfile by regexes
# example 1:	filter_tabfile mntpt=".*/sd[abc].*" type="zfs" /dev/fstab
# example 2:	filter_tabfile mntpt=/ type=zfs /dev/fstab
# example 3 w/ space: filter_tabfile dev="pool 1"
# example 4 w/ space: filter_tabfile dev="pool\0401"
#
# args:		tabfile (e.g. /etc/fstab, /etc/mtab, /proc/self/mounts)
#		filter regexes in the form of '<filter>=<value>'
#		    (valid filters are:	dev, mntpt, type, opts)
# output:	matching entries (spaces translated to \0)
# returns:	boolean
#
filter_tabfile()
{
	local tabfile="${1}"; shift

	local dev="$(parsearg dev "$@")"
	local mntpt="$(parsearg mntpt "$@")"
	local type="$(parsearg type "$@")"
	local opts="$(parsearg opts "$@")"

	if [ "${dev}${mntpt}${type}${opts}" = "" ]
	then
		echo "Invalid filter: \'$*\'" >&2
		return 1
	fi

	local lines="$( \
	    grep -vE '^#' "${tabfile}" | \
	    grep -Ei "^${dev:-[^ ]+} ${mntpt:-[^ ]+} ${type:-[^ ]+} ${opts:-[^ ]+}" | \
	    sed 's/ /\x00/g; s/\\\040/ /g; s/\\\011/\t/g'
	    )"

	[ $(printf "%s" "${lines}" | wc -l) -gt 1 ] && \
	    echo 'Warning: multiple matches; only first one returned.' >&2

	printf "%s" "${lines}" | head -1

	return 0
}

# Get entry from fstab
#
# args:		filter (see filter_tabfile())
# output:	matching mtab entry
# returns:	boolean
#
get_fstab_entry()
{
	filter_tabfile /etc/fstab "$@"

	return $?
}

# Get entry from mtab
#
# args:		filter (see filter_tabfile())
# output:	matching mtab entry
# returns:	boolean
#
get_mtab_entry()
{
	filter_tabfile /proc/self/mounts "$@"

	return $?
}

# Check for entry in tabfile (fstab, mtab)
#
# args:		filter (see filter_tabfile())
#		    (backwards compatibility:	specify device only)
# output:	-
# returns:	boolean
#
in_tabfile()
{
	local tabfile="${1}";	shift
	local compatfilter

	# backwards compatibility
	echo "$@" | grep -qEi '(dev|mntpt|type|opts)=' || \
	    compatfilter="dev=${1}"

    	do_quiet filter_tabfile "${tabfile}" "${compatfilter:-$@}"

	return $?
}

# Check for device entry in fstab
# args:		filter (see filter_tabfile())
#		    (backwards compatibility:	specify device only)
# output:	-
# returns:	boolean
#
in_fstab()
{

    	in_tabfile /etc/fstab "$@"

	return $?
}

# Check for device entry in mtab
#
# args:		filter (see filter_tabfile())
#		    (backwards compatibility:	specify device only)
# output:	-
# returns:	boolean
#
in_mtab()
{
    	in_tabfile /proc/self/mounts "$@"

	return $?
}

# Check if mountpoint is mounted
# (kept as alias for bakwards compatibility)
#
# args:		mountpoint
# output:	-
# returns:	boolean
#
is_mounted()
{
	local mntpt="${1}"

	in_mtab mntpt="${mntpt}"

	return $?
}
